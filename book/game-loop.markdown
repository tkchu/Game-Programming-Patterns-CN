^title 游戏循环
^section 序列模式

## 意图

*将游戏的处理过程和玩家输入解耦，和处理器速度解耦。*

## 动机

如果本书中有一个不可或缺模式，那就是这个了。
游戏循环是“游戏设计模式”的精华例子。
几乎每个游戏都有，两两不同，除游戏外几乎没有程序使用。

为了看看它多有用，让我们快速缅怀往事。
计算机程序的早先日子，每个人都长着<span name="beard">胡子</span>，程序像洗碗机一样工作。
你输入一堆代码，按个按钮，等待，然后获得结果，完成。
这些都是*批处理*程序——一旦工作完成，程序就停止了。

<aside name="beard">

Ada Lovelace和Rear Admiral Grace Hopper都有名义上的胡须。

</aside>

你在今日仍然能看到这些，虽然感谢上天我们不必在打孔纸上面编写它们了。
终端脚本，命令行程序，甚至将Markdown翻译成这本书的Python脚本都是批处理程序。

### 采访CPU

最终，程序员意识到将批处理代码留在计算办公室，几个小时后获得结果，这样找程序漏洞又慢有糟糕。
他们想要立即的反馈。*交互式*程序诞生了。
第一批交互式程序中的就有游戏：

<span name="cave"></span>

    YOU ARE STANDING AT THE END OF A ROAD BEFORE A SMALL BRICK
    BUILDING . AROUND YOU IS A FOREST. A SMALL
    STREAM FLOWS OUT OF THE BUILDING AND DOWN A GULLY.

    > GO IN
    YOU ARE INSIDE A BUILDING, A WELL HOUSE FOR A LARGE SPRING.

<aside name="cave">

这是[Colossal Cave Adventure](http://en.wikipedia.org/wiki/Colossal_Cave_Adventure)，史上首个冒险游戏。

</aside>

你可以和这个程序进行一些交流。
它等待你的输入，然后回应你。
你再回复，就像你在幼儿园中学到的那样轮流做事。
在你的回合，它坐在那里啥也不做。像这样：

<span name="exit"></span>

^code 1

<aside name="exit">

这会永久循环，所以没法退出游戏。
真实的游戏会做些`while (!done)`，设置`done`为真来退出。
我省略了那些来保持简单。

</aside>

### 事件循环

如果你剥开现代的图形UI的外皮，会惊讶地发现它们与老旧的冒险游戏差不多。
你的文本处理器通常呆在那里什么也不做，直到按了个键或者点了什么东西：

^code 2

最大的不同是，不使用*文本命令*，程序等待*用户输入事件*——鼠标点击和按键按下。
还是和以前的老式文本冒险游戏一样，程序<span name="idle">*阻塞*</span>等待用户输入，这是一个问题。

不像大多数其他软件，游戏即使没有玩家输入时也继续运行。
如果你站在那里看着屏幕，游戏不会冻结。动画继续动着。视觉效果继续闪烁。
如果不幸的话，怪物继续吞噬你的英雄。

<aside name="idle">

大多数事件循环有“空转”事件，这样你可以无需用户输入间歇地做事。
对于闪烁的光标或者进度条已经足够了，但对于游戏就太原始了。

</aside>

这是游戏循环的第一个关键部分：*它处理用户输入，但是不等待它*。循环总是继续旋转：

^code 3

我们之后会改善它，但是基本部分都在这里了。
`processInput()`处理上次调用到现在的任何输入。
然后<span name="update">`update()`</span>运行游戏模拟的下一步。
这运行了AI和物理（通常是这种顺序）。
最终，`render()`绘制游戏，这样玩家可以看到发生了什么。

<aside name="update">

就像你可以从名字中猜到的，`update()`是使用<a href="update-method.html" class="pattern">更新方法</a>模式的好地方。

</aside>

### 时间之外的世界

如果这个循环不在输入阻塞，这就带来了明显的问题，要转*多快*？
每次进行游戏循环都会发展一定的游戏状态。
从游戏世界的居民看来，他们手上的表就会<span name="tick">滴答</span>一下。

<aside name="tick">

运行游戏循环一次的常用术语就是“滴答”和“帧”。

</aside>

同时，*玩家的*真实手表也在滴答着。
如果我们用实际时间来测算游戏循环运行的速度，就得到了游戏的“帧每秒”。
如果游戏循环的更快，FPS就更高，游戏运行的更流畅更快。
如果很慢，游戏看上去就像是慢动作电影。

我们现在写的这个循环是能转多快转多快，两个因素决定了帧率。
第一个是*每帧要做多少工作*。复杂的物理，众多游戏对象，图形细节都让CPU和GPU繁忙，这决定了需要多久能完成一帧。

第二个是*潜在平台的速度。*更快的芯片可以在同样的时间执行更多的代码。
多核，GPU组，独立声卡，以及系统的调度都影响了在一次滴答中能够做多少东西。

### 每秒的秒数

在早期的视频游戏中，第二个参数是固定的。
如果你为NES或者Apple IIe写游戏，你*明确*知道游戏运行在什么CPU上。
你可以（而且事实也如此）为它特制代码。
你需要担忧的是每次滴答要做多少工作。

老些的游戏被仔细地编码，一帧只做足够的工作，这样游戏可以开发者想要的速率运行。
但是如果你想要在快些或者慢些的<span name="turbo">机器</span>上运行同一游戏，游戏速度本身就会加速或减速。

<aside name="turbo">

这就是为什么老式计算机通常有“[turbo](http://en.wikipedia.org/wiki/Turbo_button )”按钮。
新的计算机更快而无法玩老游戏，因为游戏会运行的过快。*关闭*turbo按钮，会减慢计算机的运行速度，就可以运行老游戏了。

</aside>

现在，很少有开发者可以奢侈地知道游戏运行的硬件条件。游戏必须自动适应多种设备。

这就是游戏循环的另一个关键任务：*不管潜在的硬件条件，以固定速度运行。*

## 模式

一个**游戏循环**在游玩中不断运行。
每一循环回合，它无阻塞地**处理玩家输入**，**更新游戏状态**，**渲染游戏**。
它追踪时间的消耗来**控制游戏的速度。**

## 何时使用

使用错误的模式比不使用模式更糟，所以这节通常是要小心过于热衷。
设计模式的目标不是往代码库里尽可能的塞东西。

但是这个模式有所不同。我可以很自信的说你*会*使用这个模式。
如果你使用一个游戏<span name="engine">引擎</span>，你不需要自己写，但是它还在那里。

<aside name="engine">

对于我，这是“引擎”与“库”的不同之处。
通过库，你拥有游戏循环，调用库。
引擎拥有游戏循环，调用*你的*代码。

</aside>

你可能认为在做回合制游戏时不需要它。
但是哪怕是那里，就算*游戏状态*到玩家回合才改变，*视觉*和*听觉*状态仍会改变。
动画和音乐会继续运行，哪怕游戏在“等待”你进行你的回合。

## 记住

我们这里谈到的循环是游戏代码中最重要的部分。
有人说程序会花费<span name="percent">90%</span>的事件在10%的代码上。
游戏循环代码肯定在这10%中。
好好对待代码，注意它的效率。

<aside name="percent">

像这样使用统计学是“真正的”工程师，比如机械或电子工程师，不认真对待我们的原因。

</aside>

### 你需要与平台的事件循环协调

如果你将游戏构建在操作系统的顶层或者有图形UI和内建事件循环的平台上，
那你就有了两个应用循环在运作。
它们需要很好的配合。

有时候，你可以控制只运行其中一个。
举个例子，如果舍弃了Windows的珍贵API，`main()`可以只有一个游戏循环。
在里面，你可以调用`PeekMessage()`来处理和分发系统的事件。
不像`GetMessage()`，`PeekMessage()`没有阻塞等待用户输入，
因此你的游戏循环会保持运作。

其他的平台不会让你这么轻松的选择事件循环。
如果你基于网页浏览器，事件循环被内建在浏览器的执行模型深处。
这样，你会用事件循环作为游戏循环。
你会调用`requestAnimationFrame()`之类的，它会返回代码让游戏继续运行。

## 示例代码

如此长的介绍，而游戏循环的代码实际上很直观。
我们会浏览一堆变种并比较它们的好处和坏处。

游戏循环驱动了AI，渲染和其他游戏系统，但这些不是模式的要点，
所以我们会调用虚拟的方法。在实现了`render()`，`update()`之后，
剩下的作为（挑战！）练习给读者。

### 跑，能跑多快跑多快

我们已经看到了可能是最简单的游戏循环：

^code 3

它的问题是你不能控制游戏运行的有多快。
在快速机器上，循环会运行的太快，玩家看不清发生了什么。
在慢速机器上，游戏在爬行。
如果游戏的一部分有大量内容或者做了很多AI或物理，游戏就会慢一些。

### 休息一下

我们看到的第一个变化是增加一个简单的修复。
假设你想要你的游戏以60FPS运行。这样每帧大约16毫秒。
只要你用少于这个时间可靠地进行游戏所有的处理和渲染，就可以以稳定的帧率运行。
你需要做的就是处理这一帧然后*等待*，直到是时候处理下一个，就像这样：

<img src="images/game-loop-simple.png" alt="A simple game loop flowchart. Process Input &rarr; Update Game &rarr; Render &rarr; Wait, then loop back to the beginning." />

代码看上去像这样：

<aside name="16">

*1000 ms / FPS = ms per frame*.

</aside>

^code 4

如果它很快的处理完一帧，这里的`sleep()`保证了游戏不会运行太*快*。
如果你的游戏运行太*慢*这无法帮忙。
如果需要超过16ms来更新并渲染一帧，休眠的时间就变成了*负的*。
如果计算机能回退时间，很多事情就很容易了，但是它不能。

相反，游戏变慢了。
可以通过每帧少做些工作来解决这个问题——减少物理效果和绚丽光影，或者把AI变笨。
但是这影响了玩家的游戏体验，哪怕是那些有快速机器的。

### 一小步，一大步

让我们尝试一些更加复杂的东西。我们拥有的问题基本上是：

  1. 每次更新将游戏时间推动一个固定量。

  2. 这消耗一定量的*真实*时间来处理它。

如果第二步消耗的时间超过第一步，游戏变慢了。
如果它需要超过16ms来推动游戏时间16ms，它永远跟不上。
但是如果一步中推动游戏时间*超过*16ms，那我们可以减少更新频率，仍可以跟得上。

接着的思路是基于上帧到现在有多少*真实*时间流逝来选择前进的时间。
这一帧花费的时间越长，游戏的间隔越大。
它总能跟上真实时间，因为它走的步子越来越大。
有人称之为*变化的*或者*流动的*时间间隔。它看上去像是：

^code 5

每一帧，我们计算上次游戏更新（`elapsed`）到现在有多少*真实*时间过去了。
当我们更新游戏状态时将其传入。
游戏引擎负责推进游戏世界确定的时间量。

假设有一颗子弹跨过屏幕。
使用固定的时间间隔，在每一帧中，你根据它的速度移动它。
使用变化的时间间隔，你*根据过去的时间决定速度增加的比例*。
随着时间间隔增加，子弹在每帧间移动的更远。
无论是二十个快的小间隔还是四个慢的大间隔，子弹在*真实*时间里移动*同样*多的距离。
这看上去是获胜者：

 *  游戏在不同的硬件上以固定的速度运行。

 *  使用更快机器的玩家获得了更流畅的游戏体验。

但是，悲哀，这里有一个严重的问题：
游戏不再是<span name="deterministic">确定的</span>了，也不再稳定。
这是我们给自己挖的一个坑：

<aside name="deterministic">

“确定的”代表每次你运行程序，如果你给了它同样的输入，你就获得同样的输出。你可以想得到，在确定的程序中追踪漏洞更容易——一次找到造成漏洞的输入，每次你都能重现之。

计算机本身是确定的；它们机械地遵循程序。非确定性出现在在纷乱的真实世界加入时。举个例子，网络，系统时钟，和线程调度都依赖于超出程序控制的外部世界。

</aside>

假设我们有个双人联网游戏，Fred的游戏机是性能猛兽，而George正在使用他祖母的老爷机。
前面提到的子弹在他们的屏幕上飞行。
在Fred的机器上，游戏跑的超级快，每个时间间隔都很小。
比如，我们塞了50帧在子弹穿过屏幕的那一秒。
可怜的George的机器只能跑到大约5帧。

这就意味着在Fred的机器上，物理引擎每秒更新50次位置，但是George的只能做5次。
大多数游戏使用浮点数，它们有*每轮误差*。
每次你将两个浮点数加在一起，获得的结果就会有点偏差。
Fred的机器做了10倍多的操作，所以它的误差要比George的更大。
*同样*的子弹最终在他们的机器上到了*不同的位置*。

这是使用变化时间可引起的一个问题，但是还有更多。
为了以真实时间运行，游戏图形引擎是实际机制法则的近似值。
为了从<span name="blowup">爆炸</span>计算这些近似值，添加了阻尼。
这个阻尼每次时间间隔都被小心的调整。
改变它，物理就不再稳定。

<aside name="blowup">

“爆炸”在这里就是它的字面意思。当物理引擎卡住，对象获得了完全错误的速度，把它们射到了天空中。

</aside>

这种不稳定性太糟了，这个例子在这里的唯一原因是作为警示寓言，引领我们到更好的东西……

### 追逐游戏

游戏中<span name="render">渲染</span>通常*不会*被动态时间间隔影响到。
由于渲染引擎使用时间上的一瞬，它不会计算上次到现在过了多久。
它在事物该在的地方渲染。

<aside name="render">

这或多或少是真的。像动态模糊的东西会被时间间隔影响，但如果它们有一点延迟，玩家通常不会注意到。

</aside>

我们可以利用这点作为优势。
用固定的时间间隔*更新*游戏，因为这让所有事情变得简单，物理和AI也更加稳定。
但是我们允许灵活*渲染*来释放一些处理器时间。

它像这样运作：自上一次游戏循环前进定量的时间。
这就是需要为游戏的“现在”模拟前进，追上玩家的时间。
我们使用一*系列*的*固定*时间间隔。
代码看上去像是这样的：

^code 6

这里还有几个小块。
在每一帧的开头，基于有多少真实时间过去更新`lag`。
这测量了游戏世界时钟比真实世界落后了多少，直到追上。
一旦我们追上，我们就渲染然后重新开始。
你可以将其视觉化如下：

<img src="images/game-loop-fixed.png" alt="A modified flowchart. Process Input &rarr; Update Game &rarr; Wait, then loop back to this step then &rarr; Render &rarr; Loop back to the beginning." />

注意这里的时间间隔不是*可见的*帧率了。
`MS_PER_UPDATE`只是我们更新游戏的*间隔*。
这个间隔越短，需要越多的处理时间来追上真实时间。
它越长，游戏抖动的越厉害。
理想上，你想要它特别短，通常快过60FPS，所以游戏在快速机器上会有高效的表现。

但是小心不要把它整得*太*短了。
你需要保证即使在<span name="bail">最慢</span>的硬件上，这个时间间隔长于处理一个`update()`的时间。
否则，你的游戏就跟不上了。

<aside name="bail">

我暂时不谈这个，但你可以通过限定内层循环最多迭代数量来保证这一点。
游戏会变慢，但是比完全卡死要好。

</aside>

幸运的是，我们给自己弄出了一些活动空间。
技巧是我们将*渲染拉出了更新循环*。
这释放了很大一部分CPU时间。
结果是游戏以固定速率*模拟*，使用了对于硬件安全的固定时间间隔。
只是玩家的*视觉窗口*在慢速机器上会有抖动。

### 卡在中间

我们还剩一个问题，就是剩下的延迟。
以固定的时间间隔更新游戏，但是在任意时间渲染。
这就意味着从玩家的角度看，游戏经常在两次更新之间的时候显示。

这是时间线：

<img src="images/game-loop-timeline.png" alt="A timeline containing evenly spaced Updates and intermittent Renders." />

就像你看到的那样，我们以紧凑固定的间隔更新。
同时，我们在任何可以的时候渲染。
它比更新发生的要少，而且也不稳定。
两者都没问题。糟糕的是，我们不总能在正确的时间点渲染。
看看第三次渲染时间。它在两次更新之间。

<img src="images/game-loop-timeline-close.png" alt="Close-up of the timeline showing Renders falling between Update steps." />

想象子弹飞过屏幕。第一次更新中，它在左边。
第二次更新将它移到了右边。
这个游戏在两次更新间的时间点渲染，所以玩家期待看到子弹在屏幕的中间。
而我们现在的实现中，它还在左边。这意味着移动看上去是锯齿状的。

方便的是，我们*实际*知道渲染时距离两帧的时间：它被存储在`lag`中。
我们在它比更新时间间隔小时取出，而不是它是*零*的时候。
剩余量？那就是到下一帧的时间。

当我们要渲染时，我们会将其传入：

<span name="normal"></span>

^code 7

<aside name="normal">

我们在这里除以`MS_PER_UPDATE`来*正规化*值。
传给`render()`在0（恰巧在前一帧）到1.0（恰巧在下一帧），不管时间更新间隔是多大。
这样，渲染引擎不必担心帧率。它只需处理0到1的值。

</aside>

渲染器知道每个游戏对象*以及它当前的速度*。
假设子弹在屏幕左边20像素的地方，正在以400像素每帧的速度向右移动。
如果在两帧中间，我们会传0.5给`render()`。
它绘制了半帧之前的图形，在220像素，好啦，平滑移动。

当然，也许这种推断是错误的。
在我们计算下一帧时，也许会发现子弹碰撞到另一障碍或减速或别的什么。
我们在它上一帧和我们*认为下一帧的位置之间插值。
但是在完成物理和AI更新后我们才能真的知道。

所以推断有猜测的成分，有时候结果是错误的。
但是，幸运的，这种修正通常不可感知。
最起码，它们比你不使用推断导致的结巴更不明显。

## 设计决策

不管这一章的长度，我没提的超过我包含的。
一旦你将显示的刷新频率，多线程，多GPU，加到里面，真正的游戏循环就会变得毛绒绒。
在高层中，这里还有一些问题你需要回答：

### 你拥有游戏循环，还是平台？

与其说这是你的选择，不如说有人为你选了。
如果你在做浏览器中的游戏，你很可能*不能*写自己的经典游戏循环。
浏览器本身的事件驱动阻碍了这一点。
同样，如果你使用现存的游戏引擎，你很可能依赖于它的游戏循环而不是自己写一个。

 *  **使用平台的事件循环：**

     *  *简单*。你不必担心写和优化自己的游戏核心循环。

     *  *平台友好。*你不必明确地给平台时间处理它自己的事件，缓存事件，或者任何管理平台输入模型和你的不同之处。

     *  *你失去了对时间的控制。*平台会在它方便时调用代码。如果这不如你想要的平滑或者频繁，太糟了。更糟的是，大多数应用的事件循环没有为游戏设计，通常*是*又慢又抖动。

 *  **使用游戏引擎的循环：**

     *  *不必自己写。*写游戏循环非常需要技巧。由于是每帧都要执行的核心代码，小小的漏洞或者性能问题就对游戏有巨大的影响。紧密的游戏循环是使用现有引擎的原因之一。

     *  *不必自己写。*当然，硬币的另一面是，如果你*真的*要的不是引擎给的，你就失去了控制。

 *  **自己写：**

     *  *完全的控制。*你可以做任何想做的事情。你可以为游戏的需求订制。

     *  *你需要与平台交互。*应用框架和操作系统通常有时间片去处理事件和做其他工作。如果你拥有应用的核心循环，它就没有。你得显式定期检查，保证框架没有挂起或者糊涂。

### 如何管理能量消耗？

这在五年前还不是问题。
游戏运行在插到插座上的或者专用的设备上。
但是随着智能手机，笔记本以及移动游戏的发展，这些东西现在需要关注了。
能完美运行但会耗干三十分钟前充的电，并将手机变成空间加热器，可不是一个能让人开心的游戏。

现在，你需要考虑的不仅仅是让游戏看上去很好，同时也要尽可能少的使用CPU。
如果让需要的工作在一帧之内完成后，让CPU睡眠，那会对性能造成*上限*。

 *  **尽可能快的运行：**

    这就是你通常想让PC游戏做的事情（即使在笔记本上运行的数目不断增加）。游戏循环永远不会显式告诉系统休眠。相反，空闲的循环被划在提升FPS或者图像显示上了。

    这会给你最好的游戏体验。但是，也会尽可能多的使用电量。如果玩家在笔记本上玩，他们得到了一个很好的笔记本加热器。

 *  **固定帧率**

    移动游戏更加注意游戏体验质量，而不是图形细节的最大化。很多这种游戏都会设置最大帧率（通常是30或60FPS）。如果游戏循环在分配的时间片消耗完之前完成，在剩余的时间它会休眠。

    这给了玩家“足够好的”游戏体验，也让背后的电池轻松了一点。

### 你如何控制游戏速度？

游戏循环有两个关键部分：不阻塞用户输入和对通过事件的适应。
输入很直观。魔力之处在于你如何处理事件。
这里有<span name="platform">数不尽的</span>游戏可运行的平台，
每个游戏都能在其中一些上运行。
如何适应变化就是关键。

<aside name="platform">

创作游戏看来是人类的天性，因为每当我们建构可以计算的机器，首先做的就是在上面编游戏。
PDP-1是一个仅有4096字内存的2kHz机器，但是Steve Russell和他的朋友也在上面创建了Spacewar!。

</aside>

 *  **固定间隔，没有同步：**

    这是我们第一个样例代码。你只需尽可能的快运行游戏。

     *  *简单*。这是主要的（好吧，唯一的）好处。

     *  *游戏速度直接与硬件和游戏复杂度相关。*主要的缺点是如果有变化，会直接影响游戏速度。它与游戏循环咬死了。

 *  **固定间隔，有同步：**

    下一步对复杂度控制是使用固定的时间间隔，但是在循环的末尾增加同步点，保证游戏不会运行的过快。

     *  *还是很简单。*这比过于简单而不能运行的例子只多了一行代码。在多数游戏循环中，你可能*总*会做一些同步。你可能[双缓冲](double-buffer.html)图形并将缓存块与显示更新的频率同步。

     *  *电量友好。*这是移动游戏惊人重要的关注点。你不想不必要的消耗电量。通过简单的休眠几个毫秒而不是试图把更多处理塞入每个滴答，你节约了电量。

     *  *游戏不会运行的太快。*这解决了固定循环速度的一半问题。

     *  *游戏可能运行的太快。*如果花了太多时间更新和渲染一帧，播放也会减缓。因为这个风格没有分离更新和渲染，它比高级更新系统更容易碰到这点。没有扔掉*渲染*帧来追上，游戏本身会变慢。

 *  **动态间隔：**

    我把这个放在这里作为问题的解决办法之一，附加警告：大多数我认识的游戏开发者反对它。不过记住*为什么*这是坏主意是很有用的。

     *  *适应运行太快或者太慢。*如果游戏不能追上真实时间，那就要消耗越来越多的时间间隔直到它跟上。

     *  *让游戏不确定而且不稳定。*这是真正的问题，当然。特别是物理和网络部分使用动态时间间隔会愈发的困难。

 *  **Fixed update time step, variable rendering:**

 *  **固定更新间隔，动态渲染：**

    在示例代码中覆盖的最后一个选项是最复杂的，但是也是最有适应性的。它以固定时间间隔更新，但是如果需要赶上玩家的时钟，可以扔掉一些*渲染*帧。

     *  *适应运行太快或者太慢。*只要可以在真实时间上*更新*，游戏就不会落后。如果玩家的机器是顶配，它会回以更平滑的游戏体验。

     *  *更复杂。*主要负面问题是需要在实现中写更多东西。你需要将更新时间间隔调整的尽可能小来适应高端机，同时不至于在低端机上太慢。

## 参见

 *  关于游戏循环的经典文章是Glenn Fiedler的"[Fix Your Timestep](http://gafferongames.com/game-physics/fix-your-timestep/)"。如果没有这一篇文章，这章就不会是这个样子。

 *  Witters关于[game loops](http://www.koonsolo.com/news/dewitters-gameloop/)的文章是一个很接近的亚军。

 *  [Unity](http://unity3d.com/)框架有一个复杂的游戏循环，细节在[这里][unity]有完美的解释。

[unity]: http://docs.unity3d.com/Manual/ExecutionOrder.html
